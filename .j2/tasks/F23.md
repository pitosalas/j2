# Tasks for F23 — Workflow-Ordered Next Step Logic

### T01 — Add ordering rules to the FOOTER constant in runner.py
**Status**: not started
**Description**: Update the `FOOTER` string in `.j2/runner.py` to replace the vague `<the exact slash command to run next>` hint with explicit ordering instructions: (1) if the injected `{{prev_spec_gaps}}` count is > 0, write `/refresh`; (2) else if the injected `{{missing_tasks}}` list is non-empty, write `/tasks-gen <first-entry>`; (3) else write `/task-next`. Both `{{prev_spec_gaps}}` and `{{missing_tasks}}` are injected by runner.py — Claude does not recompute them.

### T02 — Inject features-without-tasks list into FOOTER
**Status**: not started
**Description**: Extend `runner.py` so the FOOTER receives a rendered summary of which not-done features are missing task files, sorted by priority. Add a `compute_missing_tasks_summary(root, settings)` function that reads the features file, checks for task files, and returns a compact list (e.g. `F10 (High), F16 (Medium)`). Inject this into the FOOTER text so Claude can directly apply rule (2) without guessing.

### T03 — Sync scaffold/runner.py with .j2/runner.py
**Status**: not started
**Description**: The two copies of `runner.py` have diverged: `fill_template` in `scaffold/.j2/runner.py` uses sequential string replacement (buggy for overlapping keys) while `.j2/runner.py` uses a single regex pass. After T01/T02 are done, copy `.j2/runner.py` to `scaffold/.j2/runner.py` so both are identical. Add a note in the deploy template reminding that the deploy command already copies `runner.py` to the target.

### T04 — Write tests for workflow-ordered next step logic
**Status**: not started
**Description**: Add tests in `tests/` verifying: (1) `compute_missing_tasks_summary` returns features sorted by priority with missing task files, (2) the rendered FOOTER contains the ordering instructions, (3) a feature with an existing task file is not included in the missing list.

### T05 — Add prev_spec_gaps loader to build_context in runner.py
**Status**: not started
**Description**: Add a `prev_spec_gaps` loader to `build_context` in runner.py that reads the `state:` line from `.j2/state.md` and extracts the spec gap count (e.g. parses `3 spec gaps` → `3`). If `state.md` is missing or unparseable, default to `0`. This value is injected into the FOOTER as `{{prev_spec_gaps}}` so the ordering rule in T01 has a concrete number to act on without reanalyzing the spec.
