# j2 Framework Specification

## Overview

j2 is a structured software development framework that guides users through building software projects with Claude Code. It provides a step-by-step workflow driven by slash commands, where each command performs one discrete planning or development action. The framework is written in Python and designed to be used as a project starter template.

## Goals

- Provide a repeatable, guided workflow for developing software with Claude
- Make each planning step explicit and user-controlled (no automated loops)
- Support iterative refinement at each step before moving forward
- Be general-purpose initially, with tuning for ROS2 projects over time
- Be easy to install and use as a starting point for new projects

## Directory Structure

The framework is delivered as a directory tree that users copy or clone into a new project. It includes:

```
.j2/
  rules.md            # User-defined coding principles injected into all commands
  runner.py           # Master copy of the runner (authoritative source)
  specs/              # User-provided or generated project specifications
  features/           # Generated feature lists (includes per-feature status tracking)
  tasks/              # Generated task breakdowns per feature
  tasks/done/         # Archived task files after milestone is granted (pre-created)
  config/             # YAML configuration files (master copy, installed via rsync)
  templates/          # Prompt templates used by each slash command (master copy, installed via rsync)

.claude/
  commands/           # Markdown files that define slash commands (e.g. /refresh)

scaffold/
  .j2/                # User-customizable scaffold files ONLY (no duplicates of .j2/)
  .claude/commands/   # Template slash command definitions
  install.sh          # Install script
```

### Scaffold vs `.j2/` Separation Principle

`scaffold/` contains **only files that users customize per-project**: specs, features, tasks, rules.md, and slash command definitions. It does **not** contain files that are maintained as a single authoritative master copy:

- `runner.py` — master lives in `.j2/runner.py`; `install.sh` copies it to the target project
- `templates/` — master lives in `.j2/templates/`; `install.sh` rsyncs it to the target project
- `config/` — master lives in `.j2/config/`; `install.sh` rsyncs it to the target project

When `install.sh` deploys to a new project, it copies these master files from `.j2/` into the target's `.j2/` directory using `rsync --ignore-existing`, so user customizations are never overwritten on re-install.

### Archiving Conventions

**`features.md` ordering**: The file always has two sections — incomplete features first, completed features second. Within each section, features are sorted by priority (High → Medium → Low). When a feature's priority changes or its status changes to `done`, it moves to the correct position. This ordering is maintained by whoever updates the file (Claude, via commands like `/features-update` and `/milestone`).

**Task file archiving**: When a feature reaches milestone (all tasks done, tests passing), the feature's task file is moved from `.j2/tasks/<feature-id>.md` to `.j2/tasks/done/<feature-id>.md`.

The `tasks/done/` directory is pre-created by `install.sh` so it always exists.

## Configuration

All settings are stored in YAML files under `.j2/config/`. Key configuration files:

- `settings.yaml` — global framework settings (project name, language, target platform, principles file path)
- `workflow.yaml` — defines the ordered steps and which template each step uses

## Workflow Steps

The framework guides the user through a sequence of steps. Each step is triggered by a slash command and calls Claude once. The user may re-run any step or edit outputs before proceeding. All commands are idempotent — running a command twice in a row produces the same result.

### Step 1: `/refresh`
Reads the spec files from `.j2/specs/`, prints a summary, lists ambiguities and gaps, then for each clarifying question proposes a concrete suggested answer. Immediately rewrites the full spec incorporating those answers and presents it in a fenced code block for the developer to copy. No approval prompt — just produces the updated spec.

### Step 2: `/features-gen`
Reads the spec. Checks the current feature list and creates one if not present. Creates or updates the numbered feature list in `.j2/features/`. Each feature has a name, brief description, priority (high/medium/low), and status fields (implementation status, tests written, tests passing).

### Step 3: `/features-update`
Prompts interactively for a refinement request, then refines the feature list with Claude's help — adding, removing, or reprioritizing features. If the requested changes imply a gap or contradiction in the spec, also outputs an updated spec in a fenced code block.

### Step 4: `/tasks-gen`
Takes a feature ID as an inline argument (e.g. `/tasks-gen F01`); defaults to the first not-started feature if omitted. Generates a task breakdown for that feature, stored in `.j2/tasks/<feature-id>.md`. Tasks are concrete, actionable development steps.

### Step 5: `/tasks-update`
Takes a feature ID as an inline argument (e.g. `/tasks-update F01`), then prompts interactively for the refinement request. Applies the changes to that feature's task list.

### Step 6: `/task-start`
Takes a feature ID as an inline argument (e.g. `/task-start F01`); defaults to the first in-progress or not-started feature if omitted. Finds the first task in that feature's task list with status `not started` and implements it. Claude writes the code, then marks the task `done`.

### Step 6b: `/task-next`
Like `/task-start` but takes no arguments — automatically determines the logical next task by scanning the feature list for the first in-progress or not-started feature, then finding the first not-started task within it. If no logical next task can be determined (e.g. all tasks are done, or no task files exist), it exits with a clear error message rather than guessing.

### `/checkpoint`
Saves current working context to `.j2/current.md` so the developer can resume later. Can be run at any point — it is not a quality gate. After writing `current.md`, stages all changes with `git add -A`, inspects `git diff --cached --stat` to write a meaningful one-line commit message, commits, and pushes to the remote. If no upstream is set, it sets one automatically.

### `/milestone`
Takes a feature ID as an inline argument (e.g. `/milestone F01`); defaults to the current in-progress feature if omitted. Declares a feature complete. Confirms that implementation is done, tests are written, and tests are passing. Acts as a quality gate: if tests are missing or failing, the milestone is not granted. On success:
1. Moves the feature's task file from `.j2/tasks/<feature-id>.md` to `.j2/tasks/done/<feature-id>.md`
2. Moves the feature's entry in `features.md` from the incomplete section to the completed section, maintaining priority order (High → Medium → Low)
3. Creates or updates `README.md` to reflect the feature that was just completed

## Utility Commands

### `/code-review`
Reviews all source files in the project against the coding rules in `.j2/rules.md`. Outputs a numbered list of violations in task format (T01, T02, …) so they can be added as tasks and fixed. Covers style, structure, naming, test coverage, and any other rules defined in `rules.md`.

### `/deploy`
Takes a target directory path as an inline argument (e.g. `/deploy ../my-new-project`). Creates that directory and runs `install.sh` on it to bootstrap a fresh j2 project. Used to deploy the scaffold from the dev repo to a new project.

### `/continue`
Reads the `next:` field from `.j2/state.md` and executes that slash command as if the user typed it. Advances the workflow with a single keystroke. Every other command writes a `next:` recommendation to `state.md`, so `/continue` always knows what to do next.

## Command Footer and State

Every command ends with a structured, color-highlighted footer written to the terminal and also saved to `.j2/state.md`. The footer always contains exactly three lines:

- `completed:` — one sentence describing what was just done
- `state:` — three health counts: spec items without features / features without task files / tasks not yet run
- `next:` — the exact slash command the user should run next

The `next:` recommendation follows a strict priority order enforced by `runner.py`:
1. If any spec gaps exist → recommend `/refresh`
2. Else if any not-done feature (highest priority first) lacks a task file → recommend `/tasks-gen <feature-id>`
3. Else → recommend `/task-next` for the first pending task in the highest-priority not-done feature

The footer is visually distinct (color-highlighted) so it stands out from command output. The three values written to `.j2/state.md` are consumed by `/continue`.

## Slash Command Implementation

Each slash command is a markdown file under `.claude/commands/`. When invoked, Claude reads the markdown, which calls `python3 .j2/runner.py <command> --root .` to render the appropriate template from `.j2/templates/`, injecting context (spec files, feature lists, rules, etc.) via `{{placeholder}}` substitution before presenting the prompt to Claude.

Commands that require a specific feature or target pass it as an inline argument on the same line as the slash command (e.g. `/tasks-gen F01`, `/deploy ../my-project`). If no argument is provided, the runner falls back to a context-aware default. Commands that need open-ended input (e.g. a refinement request) still prompt interactively after invocation.

## Install Script

`scaffold/install.sh` bootstraps a new project:
- Verify Python 3.10+
- Install PyYAML if missing (uses `pip3` — intentional exception to the uv rule, since uv may not be present in the target environment)
- Copy `runner.py`, `templates/`, and `config/` from the j2 dev repo's `.j2/` master copies using `rsync --ignore-existing`
- Copy user-customizable scaffold files (slash commands, etc.)
- Create required directory structure including `tasks/done/`
- Validate YAML configuration files

## Target Platform

- **Language**: Python 3.10+
- **Initial target**: General-purpose software projects
- **Future target**: ROS2 packages and workspaces

## Constraints and Principles

- Each slash command invokes Claude exactly once — no automated multi-step loops
- The user reviews and approves output at each step before proceeding
- All state is stored in files (YAML and Markdown), not in memory
- No external dependencies beyond Python standard library and PyYAML
- Framework directories are prefixed with `.j2/` to stay out of the way of project code
- Commands that need a feature ID or target path take it as an inline argument (e.g. `/tasks-gen F01`); if omitted, the runner uses a context-aware default. Open-ended inputs (e.g. refinement requests) are still prompted interactively.
- `scaffold/` never duplicates files that have a master copy in `.j2/`; install.sh is the single deployment mechanism
- `/milestone` always creates or updates `README.md` to reflect the newly completed feature; the README should be open-source-worthy and kept current with each milestone
