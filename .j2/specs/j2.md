# j2 Framework Specification

## Overview

j2 is a structured software development framework that guides users through building software projects with Claude Code. It provides a step-by-step workflow driven by slash commands, where each command performs one discrete planning or development action. The framework is written in Python and designed to be used as a project starter template.

## Goals

- Provide a repeatable, guided workflow for developing software with Claude
- Make each planning step explicit and user-controlled (no automated loops)
- Support iterative refinement at each step before moving forward
- Be general-purpose initially, with tuning for ROS2 projects over time
- Be easy to install and use as a starting point for new projects

## Directory Structure

The framework is delivered as a directory tree that users copy or clone into a new project. It includes:

```
.j2/
  prompt.md           # Meta-instructions for Claude about the framework
  rules.md            # User-defined coding principles injected into all commands
  specs/              # User-provided or generated project specifications
  features/           # Generated feature lists (includes per-feature status tracking)
  tasks/              # Generated task breakdowns per feature
  config/             # YAML configuration files
  templates/          # Plain-text prompt templates used by each slash command

.claude/
  commands/           # Markdown files that define slash commands (e.g. /refresh)

scaffold/
  .j2/                # Template copy of .j2/ shipped with the framework
  .claude/commands/   # Template slash command definitions
  install.sh          # Install script
```

## Configuration

All settings are stored in YAML files under `.j2/config/`. Key configuration files:

- `settings.yaml` — global framework settings (project name, language, target platform, principles file path)
- `workflow.yaml` — defines the ordered steps and which template each step uses

## Workflow Steps

The framework guides the user through a sequence of steps. Each step is triggered by a slash command and calls Claude once. The user may re-run any step or edit outputs before proceeding. All commands should be idempotent, which is, I can run them any time and they will do the same thing if run twice in a row.

### Step 1: `/refresh`
Reads the spec files from `.j2/specs/`, prints a summary, lists ambiguities and gaps, then for each clarifying question proposes a concrete suggested answer. Immediately rewrites the full spec incorporating those answers and presents it in a fenced code block for the developer to copy. No approval prompt — just produces the updated spec.

### Step 2: `/features-gen`
Reads the spec. Checks the current feature list and creates one if not present. Creates or updates the numbered feature list in `.j2/features/`. Each feature has a name, brief description, priority (high/medium/low), and status fields (implementation status, tests written, tests passing).

### Step 3: `/features-refine`
Allows the user to interactively refine the feature list with Claude's help — adding, removing, or reprioritizing features. If the requested changes imply a gap or contradiction in the spec, also outputs an updated spec in a fenced code block.

### Step 4: `/tasks-gen`
Takes a feature identifier and generates a task breakdown for that feature, stored in `.j2/tasks/<feature-id>.md`. Tasks are concrete, actionable development steps. Run once per feature.

### Step 5: `/tasks-refine`
Interactive refinement of task lists for a given feature.

### Step 6: `/task-start`
Prompts the user for a feature ID, suggesting the first in-progress or not-started feature as the default. Finds the first task in that feature's task list with status `not started` and implements it. Claude writes the code, then marks the task `done`.

### Step 6b: `/task-next`
Like `/task-start` but without arguments — automatically determines the logical next task by scanning the feature list for the first in-progress or not-started feature, then finding the first not-started task within it. If no logical next task can be determined (e.g. all tasks are done, or no task files exist), it exits with a clear error message rather than guessing.

### Step 7: `/try`
Copies all project files into a timestamped snapshot directory under `snapshots/` for experimentation. No quality checks — just a raw snapshot so the developer can play with the current state without affecting the working directory.

### Step 8: `/checkpoint`
Saves current working context to `.j2/current.md` so the developer can resume later. Can be run at any point — it is not a quality gate.

### Step 9: `/milestone`
Declares a feature complete. Confirms that implementation is done, tests are written, and tests are passing. Acts as a quality gate: if tests are missing or failing, the milestone is not granted.

## Utility Commands

### `/deploy <directory>`
Creates the specified directory and runs `install.sh` on it to install a fresh copy of the j2 scaffold. Used to bootstrap a new project from the j2 dev repo.

## Slash Command Implementation

Each slash command is a markdown file under `.claude/commands/`. When invoked, Claude reads the markdown, which calls `python3 scaffold/.j2/runner.py <command> --root .` to render the appropriate template from `.j2/templates/`, injecting context (spec files, feature lists, rules, etc.) via `{{placeholder}}` substitution before presenting the prompt to Claude.

## Install Script

An `install.sh` shell script is provided to:
- Verify Python version (3.10+)
- Create the required directory structure if missing
- Copy template files and slash command definitions into place
- Validate YAML configuration

## Target Platform

- **Language**: Python 3.10+
- **Initial target**: General-purpose software projects
- **Future target**: ROS2 packages and workspaces

## Constraints and Principles

- Each slash command invokes Claude exactly once — no automated multi-step loops
- The user reviews and approves output at each step before proceeding
- All state is stored in files (YAML and Markdown), not in memory
- No external dependencies beyond Python standard library and PyYAML
- Framework directories are prefixed with `.j2/` to stay out of the way of project code
