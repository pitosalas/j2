# j2 Framework Specification

## Overview

j2 is a structured software development framework that guides users through building software projects with Claude Code. It provides a step-by-step workflow driven by slash commands, where each command performs one discrete planning or development action. The framework is written in Python and designed to be used as a project starter template.

## Goals

- Provide a repeatable, guided workflow for developing software with Claude
- Make each planning step explicit and user-controlled (no automated loops)
- Support iterative refinement at each step before moving forward
- Be general-purpose initially, with tuning for ROS2 projects over time
- Be easy to install and use as a starting point for new projects

## Directory Structure

The framework is delivered as a directory tree that users copy or clone into a new project. It includes:

```
.j2/
  prompt.md           # Meta-instructions for Claude about the framework
  rules.md            # User-defined coding principles injected into all commands
  specs/              # User-provided or generated project specifications
  features/           # Generated feature lists (includes per-feature status tracking)
  tasks/              # Generated task breakdowns per feature
  config/             # YAML configuration files
  templates/          # Jinja2 prompt templates used by each slash command

.claude/
  commands/           # Markdown files that define slash commands (e.g. /spec-review)

scaffold/
  .j2/                # Template copy of .j2/ shipped with the framework
  .claude/commands/   # Template slash command definitions
  install.sh          # Install script
```

## Configuration

All settings are stored in YAML files under `.j2/config/`. Key configuration files:

- `settings.yaml` — global framework settings (project name, language, target platform, principles file path)
- `workflow.yaml` — defines the ordered steps and which template each step uses

## Workflow Steps

The framework guides the user through a sequence of steps. Each step is triggered by a slash command and calls Claude once. The user may re-run any step or edit outputs before proceeding.

### Step 1: `/spec-review`
Reads the spec files from `.j2/specs/`, prints a summary and clarifying questions to stdout, then offers to make changes to the spec based on the user's response.

### Step 2: `/gen-features`
Reads the spec and generates a numbered feature list in `.j2/features/`. Each feature has a name, brief description, priority (high/medium/low), and status fields (implementation status, tests written, tests passing).

### Step 3: `/refine-features`
Allows the user to interactively refine the feature list with Claude's help — adding, removing, or reprioritizing features.

### Step 4: `/gen-tasks`
Takes a feature identifier and generates a task breakdown for that feature, stored in `.j2/tasks/<feature-name>.md`. Tasks are concrete, actionable development steps. Run once per feature.

### Step 5: `/refine-tasks`
Interactive refinement of task lists for a given feature.

### Step 6: `/start-task`
Begins implementation of a specified task. Claude reads the task description and writes code.

### Step 6b: `/next-task`
Like `/start-task` but without arguments — automatically determines the logical next task by scanning the feature list for the first in-progress or not-started feature, then finding the first not-started task within it. If no logical next task can be determined (e.g. all tasks are done, or no task files exist), it exits with a clear error message rather than guessing.

### Step 7: `/try`
Copies all project files into a timestamped snapshot directory under `snapshots/` for experimentation. No quality checks — just a raw snapshot so the developer can play with the current state without affecting the working directory.

### Step 8: `/checkpoint`
Saves current working context to `.j2/current.md` so the developer can resume later. Can be run at any point — it is not a quality gate.

### Step 9: `/milestone`
Declares a feature complete. Confirms that implementation is done, tests are written, and tests are passing. Acts as a quality gate: if tests are missing or failing, the milestone is not granted.

## Slash Command Implementation

Each slash command is a markdown file under `.claude/commands/`. When invoked, Claude reads the markdown, which calls `python3 scaffold/.j2/runner.py <command> --root .` to render the appropriate Jinja2 template from `.j2/templates/`, injecting context (spec files, feature lists, rules, etc.) before presenting the prompt to Claude.

## Install Script

An `install.sh` shell script is provided to:
- Verify Python version (3.10+)
- Create the required directory structure if missing
- Copy template files and slash command definitions into place
- Validate YAML configuration

## Target Platform

- **Language**: Python 3.10+
- **Initial target**: General-purpose software projects
- **Future target**: ROS2 packages and workspaces

## Constraints and Principles

- Each slash command invokes Claude exactly once — no automated multi-step loops
- The user reviews and approves output at each step before proceeding
- All state is stored in files (YAML and Markdown), not in memory
- No external dependencies beyond Python standard library, PyYAML, and Jinja2
- Framework directories are prefixed with `.j2/` to stay out of the way of project code
