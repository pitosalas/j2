# j2 Framework Specification

## Overview

j2 is a structured software development framework that guides users through building software projects with Claude Code. It provides a step-by-step workflow driven by slash commands, where each command performs one discrete planning or development action. The framework is written in Python and can be used both as a starter template for new projects and as an overlay added to existing codebases.

## Goals

- Provide a repeatable, guided workflow for developing software with Claude
- Make each planning step explicit and user-controlled (no automated loops)
- Support iterative refinement at each step before moving forward
- Be general-purpose initially, with tuning for ROS2 projects over time
- Be easy to install — both as a starting point for new projects and as an overlay on existing codebases
- Minimize token waste: templates should inject only the context a command actually needs, not everything
- Make it easy to do unrelated tasks in parallel or in background

## Directory Structure

The framework is delivered as a directory tree that users copy or clone into a new project. It includes:

```
.j2/
  rules.md            # User-defined coding principles injected into all commands
  runner.py           # Master copy of the runner (authoritative source)
  specs/              # User-provided or generated project specifications
  features/           # Generated feature lists (includes per-feature status tracking)
  tasks/              # Generated task breakdowns per feature
  tasks/done/         # Archived task files after milestone is granted (pre-created)
  config/             # YAML configuration files (master copy, installed via rsync)
  templates/          # Prompt templates used by each slash command (master copy, installed via rsync)

.claude/
  commands/           # Markdown files that define slash commands (e.g. /refresh)

scaffold/
  .j2/                # User-customizable scaffold files ONLY (no duplicates of .j2/)
  .claude/commands/   # Template slash command definitions
  install.sh          # Install script
```

### Scaffold vs `.j2/` Separation Principle

`scaffold/` contains **only files that users customize per-project**: specs, features, tasks, rules.md, and slash command definitions. It does **not** contain files that are maintained as a single authoritative master copy:

- `runner.py` — master lives in `.j2/runner.py`; `install.sh` copies it to the target project
- `templates/` — master lives in `.j2/templates/`; `install.sh` rsyncs it to the target project
- `config/` — master lives in `.j2/config/`; `install.sh` rsyncs it to the target project

When `install.sh` deploys to a new project, it copies these master files from `.j2/` into the target's `.j2/` directory using `rsync --ignore-existing`, so user customizations are never overwritten on re-install. **Note**: upstream template changes do not propagate on re-install. To pull updated templates, delete the target files first, then re-run `install.sh`.

### Archiving Conventions

**`features.md` ordering**: The file always has two sections — incomplete features first, completed features second. Within each section, features are sorted by priority (High → Medium → Low). When a feature's priority changes or its status changes to `done`, it moves to the correct position. This ordering is maintained by whoever updates the file (Claude, via commands like `/features-update` and `/milestone`).

**Task file archiving**: When a feature reaches milestone (all tasks done, tests passing), the feature's task file is moved from `.j2/tasks/<feature-id>.md` to `.j2/tasks/done/<feature-id>.md`.

The `tasks/done/` directory is pre-created by `install.sh` so it always exists.

## Configuration

All settings are stored in YAML files under `.j2/config/`. Key configuration files:

- `settings.yaml` — global framework settings (project name, language, target platform, principles file path)
- `workflow.yaml` — defines the ordered steps and which template each step uses

## Workflow Steps

The framework guides the user through a sequence of steps. Each step is triggered by a slash command and calls Claude once. The user may re-run any step or edit outputs before proceeding. All commands are idempotent — running a command twice in a row produces the same result.

**Principles**: 
* Any command can be issued in any order. It may not do anything but it will not harm anything.
* Most commands are idempotent. When you give the same command twice, the state of the world after the first time is the same as after the second time.
* Specs are used to create features, and features are used to create tasks, and all programming is based on tasks. There will be no programming without a task explaining it and there will be no task without a feature requiring.

### Step 1: `/refresh`
Reads the spec files from `.j2/specs/`, prints a summary, lists ambiguities and gaps, then for each clarifying question proposes a concrete suggested answer. Immediately rewrites the full spec incorporating those answers and presents it in a fenced code block for the developer to copy. No approval prompt — just produces the updated spec.

### Step 2: `/features-gen`
Reads the spec. Checks the current feature list and creates one if not present. Creates or updates the numbered feature list in `.j2/features/`. Each feature has a name, brief description, priority (high/medium/low), and status fields (implementation status, tests written, tests passing).

### Step 3: `/features-update`
Prompts interactively for a refinement request, then refines the feature list with Claude's help — adding, removing, or reprioritizing features. After applying changes:
- If any new features were added, automatically generates a task file for each (equivalent to `/tasks-gen <feature-id>`) before finishing.
- Always rewrites `features.md` with two sections in order: incomplete features first (High → Medium → Low), completed features second (High → Medium → Low). This invariant must be maintained on every write.

If the requested changes imply a gap or contradiction in the spec, also outputs an updated spec in a fenced code block.

### Step 4: `/tasks-gen`
Takes a feature ID as an inline argument (e.g. `/tasks-gen F01`); defaults to the first not-started feature if omitted. Generates a task breakdown for that feature, stored in `.j2/tasks/<feature-id>.md`. Tasks are concrete, actionable development steps.

### Step 5: `/tasks-update`
Takes a feature ID as an inline argument (e.g. `/tasks-update F01`), then prompts interactively for the refinement request. Applies the changes to that feature's task list.

### Step 6: `/task-start`
Takes a feature ID as an inline argument (e.g. `/task-start F01`); defaults to the first in-progress or not-started feature if omitted. Finds the first task in that feature's task list with status `not started` and implements it. Claude writes the code, then marks the task `done`.

### Step 6b: `/task-next`
Like `/task-start` but takes no arguments — automatically determines the logical next task by scanning the feature list for the first in-progress or not-started feature, then finding the first not-started task within it. If no logical next task can be determined (e.g. all tasks are done, or no task files exist), it exits with a clear error message rather than guessing.

### Step 6c: `/task-run-all`
Takes a feature ID as an inline argument (e.g. `/task-run-all F01`); defaults to the first in-progress or not-started feature if omitted. Implements every not-started task in the feature sequentially without pausing — reads the task file, implements each task in order, updates its status to `done`, then moves to the next. After all tasks are done, runs the test suite. Does not touch `features.md` or archive the task file — that is left to `/milestone`. This command replaces the manual loop of repeatedly typing `/task-next`.

### `/features-parallel`
Takes no arguments. Scans the feature list for all not-done features that have task files. For each, launches a background Task agent with instructions to implement all not-started tasks sequentially (same behavior as `/task-run-all`). Agents work independently on separate features and do not modify shared files (`features.md`, `state.md`, `README.md`). After all agents complete, the user runs `/milestone` for each feature. This command enables parallel feature development within a single terminal session.

### `/checkpoint`
Saves current working context to `.j2/current.md` with four sections: `## In Progress`, `## Just Completed`, `## Next Steps`, `## Open Questions`. Can be run at any point — it is not a quality gate. Before committing, scans all non-done features and marks any fully-completed feature (all tasks `done`) as `done` in `features.md`, running `pytest` to set test status. After writing `current.md` and syncing feature statuses, stages all changes with `git add -A`, inspects `git diff --cached --stat` to write a meaningful one-line commit message, commits, and pushes to the remote. If no upstream is set, it sets one automatically.

### `/milestone`
Takes a feature ID as an inline argument (e.g. `/milestone F01`); defaults to the current in-progress feature if omitted. Declares a feature complete. Confirms that implementation is done, tests are written, and tests are passing. Acts as a quality gate: if tests are missing or failing, the milestone is not granted. On success:
1. Moves the feature's task file from `.j2/tasks/<feature-id>.md` to `.j2/tasks/done/<feature-id>.md`
2. Moves the feature's entry in `features.md` from the incomplete section to the completed section, maintaining priority order (High → Medium → Low)
3. Rewrites `README.md` in full to reflect all completed features (open-source-worthy: overview, feature list, install instructions, usage examples)

## Utility Commands

### `/code-review`
Reviews all source files in the project against the coding rules in `.j2/rules.md`. Outputs a numbered list of violations in task format (T01, T02, …) so they can be added as tasks and fixed. Covers style, structure, naming, test coverage, and any other rules defined in `rules.md`.

### `/deploy`
Takes a target directory path as an inline argument (e.g. `/deploy ../my-new-project`). Operates in two modes:

- **Dev repo mode** (when `scaffold/` is present): Creates the target directory and runs `install.sh` to bootstrap a fresh j2 project.
- **Clean export mode** (when `scaffold/` is absent — running from a deployed project): Copies the project to the target directory in fully working form, stripping all j2 infrastructure (`.j2/`, `.claude/commands/`, `scaffold/`, `runner.py`). The result is a standalone project with no evidence of j2.

### `/continue`
Reads the `next:` field from `.j2/state.md` and executes that slash command as if the user typed it. Advances the workflow with a single keystroke. Every other command writes a `next:` recommendation to `state.md`, so `/continue` always knows what to do next. If `state.md` does not exist (fresh project), defaults to recommending `/refresh`.

## Command Footer and State

Every command ends with a structured, color-highlighted footer written to the terminal and also saved to `.j2/state.md`. The footer always contains exactly three lines:

- `completed:` — one sentence describing what was just done
- `state:` — three health counts: spec items without features / features without task files / tasks not yet run
- `next:` — the exact slash command the user should run next

**Counting "spec items without features"**: Count the H3-level command headings in the spec that have no corresponding entry in `features.md`. If all commands have a matching feature, this count is 0.

The `next:` recommendation follows a strict priority order enforced by `runner.py`:
1. If any spec gaps exist → recommend `/refresh`
2. Else if any not-done feature (highest priority first) lacks a task file → recommend `/tasks-gen <feature-id>`
3. Else → recommend `/task-next` for the first pending task in the highest-priority not-done feature

The footer is visually distinct (color-highlighted) so it stands out from command output. The three values written to `.j2/state.md` are consumed by `/continue`.

## Slash Command Implementation

Each slash command is a markdown file under `.claude/commands/`. When invoked, Claude reads the markdown, which calls `python3 .j2/runner.py <command> --root .` to render the appropriate template from `.j2/templates/`, injecting context (spec files, feature lists, rules, etc.) via `{{placeholder}}` substitution before presenting the prompt to Claude.

Commands that require a specific feature or target pass it as an inline argument on the same line as the slash command (e.g. `/tasks-gen F01`, `/deploy ../my-project`). If no argument is provided, the runner falls back to a context-aware default. Commands that need open-ended input (e.g. a refinement request) still prompt interactively after invocation.

## Token Minimization

Templates should inject only the context a command actually needs. Every placeholder included in a template costs tokens — both in the prompt Claude receives and in the log the user scrolls past. Rules:

1. **No full spec in task-execution templates.** `/task-start` and `/task-next` should not inject `{{spec}}` or `{{features}}`. The task file already contains enough context to implement the task. They need only `{{rules}}` and the task file reference.
2. **Filter completed features.** When `{{features}}` is injected, the runner should strip features with status `done` and replace them with a one-line count (e.g. "— 27 completed features omitted —"). Only incomplete features are relevant to planning commands.
3. **Keep templates terse.** Template instruction text should be as short as possible while remaining unambiguous. Avoid repeating information that appears in the injected context.
4. **Runner output is silent on success.** `runner.py` should print only the filled template to stdout. No banners, progress messages, or diagnostics unless there is an error (which goes to stderr).

## Parallel and Background Work

Per-feature commands (`/task-start <FID>`, `/tasks-gen <FID>`, `/tasks-update <FID>`) operate on a single feature's task file and are safe to run in a separate Claude Code session concurrently with work on a different feature. Commands that modify shared files (`features.md`, `state.md`, `README.md`) — such as `/features-update`, `/milestone`, `/checkpoint` — require exclusive access and should not be run concurrently.

The framework does not enforce locking. Instead, the user is responsible for avoiding concurrent writes to the same file. The documentation and `/refresh` output should note which commands are parallel-safe.

## Install Script

`scaffold/install.sh` bootstraps a new project:
- Verify Python 3.10+
- Install PyYAML if missing (uses `pip3` — intentional exception to the uv rule, since uv may not be present in the target environment)
- Copy `runner.py`, `templates/`, and `config/` from the j2 dev repo's `.j2/` master copies using `rsync --ignore-existing`
- Copy user-customizable scaffold files (slash commands, etc.)
- Create required directory structure including `tasks/done/`
- Validate YAML configuration files

## Adopting Existing Projects

j2 can be added to a project that already has code, tests, and history. The `/adopt` command handles this in a single step.

### `/adopt`

Takes no arguments. Intended to be run once, immediately after `install.sh` has added the `.j2/` infrastructure to an existing project. Performs the following steps in order:

1. **Auto-detect project settings.** Scans the repository root for marker files (`pyproject.toml`, `package.json`, `Cargo.toml`, `CMakeLists.txt`, `go.mod`, etc.) and infers language, package manager, test runner, and framework. Writes the detected values into `.j2/config/settings.yaml`, overwriting the scaffold defaults.

2. **Generate a draft spec.** Reads the project's source files, README, config files, and directory structure. Produces a draft spec in `.j2/specs/<project-name>.md` describing the project's purpose, architecture, and existing functionality. Presents the spec in a fenced code block for the user to review and edit.

3. **Generate a feature list with existing work marked done.** Scans the codebase and the draft spec to produce `.j2/features/features.md`. Features that correspond to already-implemented, working functionality are marked `done`. Features that appear planned but unfinished are marked `in progress` or `not started`. Test detection: if a feature's code has corresponding test files with passing tests, the feature's test fields are set to `yes`/`yes`.

4. **Merge `.gitignore`.** If a `.gitignore` already exists, appends j2-specific entries (`.j2/current.md`, etc.) rather than overwriting. If no `.gitignore` exists, creates one.

5. **Merge `.claude/` config.** If `.claude/` already exists (e.g., the user has existing Claude Code settings or `CLAUDE.md`), the adopt command adds the j2 slash commands under `.claude/commands/` without disturbing other files. If a `CLAUDE.md` already exists, appends the j2 project instruction block rather than replacing it.

6. **Leave README untouched.** Unlike a fresh project, `/adopt` does not generate or overwrite `README.md`. The existing README is preserved. It will be updated naturally when the user runs `/milestone` on future features.

After `/adopt` completes, the project is fully j2-managed and the user can proceed with the normal workflow (`/refresh`, `/features-update`, `/tasks-gen`, etc.).

### Install Script Changes for Existing Projects

`install.sh` remains the entry point. When the target directory already contains source files, `install.sh` behaves identically to today (copies infrastructure with `--ignore-existing`). The intelligence lives in `/adopt`, which the user runs after install. The install script prints a message at the end: "Run /adopt to scan your existing codebase and generate a spec and feature list."

## Target Platform

- **Language**: Python 3.10+
- **Initial target**: General-purpose software projects
- **Future target**: ROS2 packages and workspaces

## Constraints and Principles

- Each slash command invokes Claude exactly once — no automated multi-step loops
- The user reviews and approves output at each step before proceeding
- All state is stored in files (YAML and Markdown), not in memory
- No external dependencies beyond Python standard library and PyYAML
- Framework directories are prefixed with `.j2/` to stay out of the way of project code
- Commands that need a feature ID or target path take it as an inline argument (e.g. `/tasks-gen F01`); if omitted, the runner uses a context-aware default. Open-ended inputs (e.g. refinement requests) are still prompted interactively.
- `scaffold/` never duplicates files that have a master copy in `.j2/`; install.sh is the single deployment mechanism
- `/milestone` always creates or updates `README.md` to reflect the newly completed feature; the README should be open-source-worthy and kept current with each milestone
- Templates must not inject context that the command does not use — every `{{placeholder}}` must earn its tokens
- Per-feature commands are parallel-safe; shared-file commands are not
